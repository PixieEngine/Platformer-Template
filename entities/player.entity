{
  "class": "Player",
  "__CODE": "self.include 'Debuggable'\n\nself.debug\n  filter: 'changed'\n  bounds: false\n  velocity: 0\n  x: 35\n  y: 35\n  \nphysics =\n  acceleration:\n    x: 1\n    y: 3\n  jumpPower: -20\n  velocity:\n    xMin: -6\n    xMax: 6\n    yMin: -13\n    yMax: 10\n\nphysics.jumpGravity = physics.acceleration.y * 0.3\n\nphysics.friction = physics.velocity.xMax / (physics.velocity.xMax + physics.acceleration.x)\nphysics.minSpeed = physics.acceleration.x * physics.friction\n\nself.on 'update', ->\n  self.playerInput()\n  \n  vel = I.velocity\n  \n  self.applyGravity(vel)\n  self.resolveCollisions(vel)\n\n  I.hflip = I.facing.x < 0 \n    \n  vel.x = vel.x * physics.friction\n      \n  self.clampVelocity(vel)\n  \nself.extend\n  applyGravity: (velocity) ->\n    if I.jumping\n      velocity.y += physics.jumpGravity\n    else\n      velocity.y += physics.acceleration.y\n      \n  clampVelocity: (velocity) ->\n    velocity.x = velocity.x.clamp(physics.velocity.xMin, physics.velocity.xMax)\n    velocity.y = velocity.y.clamp(physics.velocity.yMin, physics.velocity.yMax) \n    \n    velocity.x = 0 if velocity.x.abs() < physics.minSpeed\n\n  collide: (xOffset, yOffset, className) ->\n    engine.find(className).inject false, (hit, block) ->\n      hit || Collision.rectangular(self.bounds(xOffset, yOffset), block.bounds())\n\n  jump: ->\n    I.jumping = true\n    I.landed = false\n    I.velocity.y = physics.jumpPower   \n    \n  land: ->\n    I.landed = true\n    \n    Sound.play 'land'\n    \n    engine.add \"DustEmitter\"\n      x: I.x\n      y: I.y + I.height / 2\n      \n  playerInput: ->\n    if keydown.left\n      I.velocity.x -= physics.acceleration.x\n  \n      I.facing = Point(-1, 0)\n    else if keydown.right\n      I.velocity.x += physics.acceleration.x\n     \n      I.facing = Point(1, 0)\n    else\n      I.velocity.x = I.velocity.x.approach(0, physics.acceleration.x)\n      \n    if justPressed.z and I.landed    \n      self.jump()\n      \n    I.jumping = false unless keydown.z\n      \n  resolveCollisions: (velocity) ->\n    xSign = velocity.x.sign()\n    ySign = velocity.y.sign()\n    \n    velocity.x.abs().times ->\n      if self.collide(xSign, 0, \".solid\")\n        velocity.x = 0\n      else\n        I.x += xSign\n\n    velocity.y.abs().times ->   \n      if self.collide(0, ySign, \".solid\")                  \n        velocity.y = 0\n        unless I.landed\n          self.land()\n      else\n        I.y += ySign       ",
  "uuid": "player",
  "facing": "Point(1, 0)",
  "jumping": false,
  "landed": true,
  "onWall": false,
  "velocity": "{x: 0, y: 0}",
  "sprite": "balki",
  "scale": 0.5
}